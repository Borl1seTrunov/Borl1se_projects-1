{"ast":null,"code":"const errors = require('./errors');\nconst debug = require('debug')('node-telegram-bot-api');\nconst https = require('https');\nconst http = require('http');\nconst fs = require('fs');\nconst bl = require('bl');\nclass TelegramBotWebHook {\n  /**\n   * Sets up a webhook to receive updates\n   * @param  {TelegramBot} bot\n   * @see https://core.telegram.org/bots/api#getting-updates\n   */\n  constructor(bot) {\n    this.bot = bot;\n    this.options = typeof bot.options.webHook === 'boolean' ? {} : bot.options.webHook;\n    this.options.host = this.options.host || '0.0.0.0';\n    this.options.port = this.options.port || 8443;\n    this.options.https = this.options.https || {};\n    this.options.healthEndpoint = this.options.healthEndpoint || '/healthz';\n    this._healthRegex = new RegExp(this.options.healthEndpoint);\n    this._webServer = null;\n    this._open = false;\n    this._requestListener = this._requestListener.bind(this);\n    this._parseBody = this._parseBody.bind(this);\n    if (this.options.key && this.options.cert) {\n      debug('HTTPS WebHook enabled (by key/cert)');\n      this.options.https.key = fs.readFileSync(this.options.key);\n      this.options.https.cert = fs.readFileSync(this.options.cert);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (this.options.pfx) {\n      debug('HTTPS WebHook enabled (by pfx)');\n      this.options.https.pfx = fs.readFileSync(this.options.pfx);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (Object.keys(this.options.https).length) {\n      debug('HTTPS WebHook enabled by (https)');\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else {\n      debug('HTTP WebHook enabled');\n      this._webServer = http.createServer(this._requestListener);\n    }\n  }\n\n  /**\n   * Open WebHook by listening on the port\n   * @return {Promise}\n   */\n  open() {\n    if (this.isOpen()) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      this._webServer.listen(this.options.port, this.options.host, () => {\n        debug('WebHook listening on port %s', this.options.port);\n        this._open = true;\n        return resolve();\n      });\n      this._webServer.once('error', err => {\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Close the webHook\n   * @return {Promise}\n   */\n  close() {\n    if (!this.isOpen()) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      this._webServer.close(error => {\n        if (error) return reject(error);\n        this._open = false;\n        return resolve();\n      });\n    });\n  }\n\n  /**\n   * Return `true` if server is listening. Otherwise, `false`.\n   */\n  isOpen() {\n    // NOTE: Since `http.Server.listening` was added in v5.7.0\n    // and we still need to support Node v4,\n    // we are going to fallback to 'this._open'.\n    // The following LOC would suffice for newer versions of Node.js\n    // return this._webServer.listening;\n    return this._open;\n  }\n\n  /**\n   * Handle error thrown during processing of webhook request.\n   * @private\n   * @param  {Error} error\n   */\n  _error(error) {\n    if (!this.bot.listeners('webhook_error').length) {\n      return console.error('error: [webhook_error] %j', error); // eslint-disable-line no-console\n    }\n    return this.bot.emit('webhook_error', error);\n  }\n\n  /**\n   * Handle request body by passing it to 'callback'\n   * @private\n   */\n  _parseBody(error, body) {\n    if (error) {\n      return this._error(new errors.FatalError(error));\n    }\n    let data;\n    try {\n      data = JSON.parse(body.toString());\n    } catch (parseError) {\n      return this._error(new errors.ParseError(parseError.message));\n    }\n    return this.bot.processUpdate(data);\n  }\n\n  /**\n   * Listener for 'request' event on server\n   * @private\n   * @see https://nodejs.org/docs/latest/api/http.html#http_http_createserver_requestlistener\n   * @see https://nodejs.org/docs/latest/api/https.html#https_https_createserver_options_requestlistener\n   */\n  _requestListener(req, res) {\n    debug('WebHook request URL: %s', req.url);\n    debug('WebHook request headers: %j', req.headers);\n    if (req.url.indexOf(this.bot.token) !== -1) {\n      if (req.method !== 'POST') {\n        debug('WebHook request isn\\'t a POST');\n        res.statusCode = 418; // I'm a teabot!\n        res.end();\n      } else {\n        req.pipe(bl(this._parseBody)).on('finish', () => res.end('OK'));\n      }\n    } else if (this._healthRegex.test(req.url)) {\n      debug('WebHook health check passed');\n      res.statusCode = 200;\n      res.end('OK');\n    } else {\n      debug('WebHook request unauthorized');\n      res.statusCode = 401;\n      res.end();\n    }\n  }\n}\nmodule.exports = TelegramBotWebHook;","map":{"version":3,"names":["errors","require","debug","https","http","fs","bl","TelegramBotWebHook","constructor","bot","options","webHook","host","port","healthEndpoint","_healthRegex","RegExp","_webServer","_open","_requestListener","bind","_parseBody","key","cert","readFileSync","createServer","pfx","Object","keys","length","open","isOpen","Promise","resolve","reject","listen","once","err","close","error","_error","listeners","console","emit","body","FatalError","data","JSON","parse","toString","parseError","ParseError","message","processUpdate","req","res","url","headers","indexOf","token","method","statusCode","end","pipe","on","test","module","exports"],"sources":["/Users/boristrunov/Desktop/LevelCoin/project/node_modules/node-telegram-bot-api/src/telegramWebHook.js"],"sourcesContent":["const errors = require('./errors');\nconst debug = require('debug')('node-telegram-bot-api');\nconst https = require('https');\nconst http = require('http');\nconst fs = require('fs');\nconst bl = require('bl');\n\nclass TelegramBotWebHook {\n  /**\n   * Sets up a webhook to receive updates\n   * @param  {TelegramBot} bot\n   * @see https://core.telegram.org/bots/api#getting-updates\n   */\n  constructor(bot) {\n    this.bot = bot;\n    this.options = (typeof bot.options.webHook === 'boolean') ? {} : bot.options.webHook;\n    this.options.host = this.options.host || '0.0.0.0';\n    this.options.port = this.options.port || 8443;\n    this.options.https = this.options.https || {};\n    this.options.healthEndpoint = this.options.healthEndpoint || '/healthz';\n    this._healthRegex = new RegExp(this.options.healthEndpoint);\n    this._webServer = null;\n    this._open = false;\n    this._requestListener = this._requestListener.bind(this);\n    this._parseBody = this._parseBody.bind(this);\n\n    if (this.options.key && this.options.cert) {\n      debug('HTTPS WebHook enabled (by key/cert)');\n      this.options.https.key = fs.readFileSync(this.options.key);\n      this.options.https.cert = fs.readFileSync(this.options.cert);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (this.options.pfx) {\n      debug('HTTPS WebHook enabled (by pfx)');\n      this.options.https.pfx = fs.readFileSync(this.options.pfx);\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else if (Object.keys(this.options.https).length) {\n      debug('HTTPS WebHook enabled by (https)');\n      this._webServer = https.createServer(this.options.https, this._requestListener);\n    } else {\n      debug('HTTP WebHook enabled');\n      this._webServer = http.createServer(this._requestListener);\n    }\n  }\n\n  /**\n   * Open WebHook by listening on the port\n   * @return {Promise}\n   */\n  open() {\n    if (this.isOpen()) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      this._webServer.listen(this.options.port, this.options.host, () => {\n        debug('WebHook listening on port %s', this.options.port);\n        this._open = true;\n        return resolve();\n      });\n\n      this._webServer.once('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Close the webHook\n   * @return {Promise}\n   */\n  close() {\n    if (!this.isOpen()) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      this._webServer.close(error => {\n        if (error) return reject(error);\n        this._open = false;\n        return resolve();\n      });\n    });\n  }\n\n  /**\n   * Return `true` if server is listening. Otherwise, `false`.\n   */\n  isOpen() {\n    // NOTE: Since `http.Server.listening` was added in v5.7.0\n    // and we still need to support Node v4,\n    // we are going to fallback to 'this._open'.\n    // The following LOC would suffice for newer versions of Node.js\n    // return this._webServer.listening;\n    return this._open;\n  }\n\n  /**\n   * Handle error thrown during processing of webhook request.\n   * @private\n   * @param  {Error} error\n   */\n  _error(error) {\n    if (!this.bot.listeners('webhook_error').length) {\n      return console.error('error: [webhook_error] %j', error); // eslint-disable-line no-console\n    }\n    return this.bot.emit('webhook_error', error);\n  }\n\n  /**\n   * Handle request body by passing it to 'callback'\n   * @private\n   */\n  _parseBody(error, body) {\n    if (error) {\n      return this._error(new errors.FatalError(error));\n    }\n\n    let data;\n    try {\n      data = JSON.parse(body.toString());\n    } catch (parseError) {\n      return this._error(new errors.ParseError(parseError.message));\n    }\n\n    return this.bot.processUpdate(data);\n  }\n\n  /**\n   * Listener for 'request' event on server\n   * @private\n   * @see https://nodejs.org/docs/latest/api/http.html#http_http_createserver_requestlistener\n   * @see https://nodejs.org/docs/latest/api/https.html#https_https_createserver_options_requestlistener\n   */\n  _requestListener(req, res) {\n    debug('WebHook request URL: %s', req.url);\n    debug('WebHook request headers: %j', req.headers);\n\n    if (req.url.indexOf(this.bot.token) !== -1) {\n      if (req.method !== 'POST') {\n        debug('WebHook request isn\\'t a POST');\n        res.statusCode = 418; // I'm a teabot!\n        res.end();\n      } else {\n        req\n          .pipe(bl(this._parseBody))\n          .on('finish', () => res.end('OK'));\n      }\n    } else if (this._healthRegex.test(req.url)) {\n      debug('WebHook health check passed');\n      res.statusCode = 200;\n      res.end('OK');\n    } else {\n      debug('WebHook request unauthorized');\n      res.statusCode = 401;\n      res.end();\n    }\n  }\n}\n\nmodule.exports = TelegramBotWebHook;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}